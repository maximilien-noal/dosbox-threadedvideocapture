--- src/trunk/src/hardware/hardware.cpp	2014-01-25 15:38:48.665143223 +0100
+++ /home/max/Dev/contribs/dosbox/safe/hardware.cpp	2014-01-23 22:46:31.253629663 +0100
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2002-2013  The DOSBox Team
+ *  Copyright (C) 2002-2009  The DOSBox Team
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+/* $Id: hardware.cpp,v 1.23 2009/10/11 18:09:22 qbix79 Exp $ */
+
 
 #include <string.h>
 #include <stdlib.h>
@@ -31,8 +33,21 @@
 #include "cross.h"
 
 #if (C_SSHOT)
+
+#define C_THREADED_CAPTURE 1
+
 #include <png.h>
 #include "../libs/zmbv/zmbv.cpp"
+
+#if (C_THREADED_CAPTURE)
+#define MAX_QUEUE_SIZE 400
+
+#include "SDL.h"
+#include <queue>
+
+SDL_Thread *video_thread;
+#endif
+
 #endif
 
 static std::string capturedir;
@@ -43,40 +58,60 @@
 #define MIDI_BUF 4*1024
 #define AVI_HEADER_SIZE	500
 
+#if (C_SSHOT)
+typedef struct {
+	Bit16s		*audiobuf;
+	Bitu		audioused;
+	Bit8u		*videobuf;
+	Bit8u		*pal;
+} video_chunk_t;
+
+typedef struct {
+	FILE		*handle;
+	Bitu		frames;
+	Bit16s		audiobuf[WAVE_BUF][2];
+	Bitu		audioused;
+	Bitu		audiorate;
+	Bitu		audiowritten;
+	VideoCodec	*codec;
+	Bitu		width, height, bpp;
+	Bitu		written;
+	float		fps;
+	int			bufSize;
+	void		*buf;
+	Bit8u		*index;
+	Bitu		indexsize, indexused;
+	Bitu		flags;
+	Bitu		pitch;
+	zmbv_format_t   format;
+	bool		thread_running;
+
+#if (C_THREADED_CAPTURE)
+	std::queue<video_chunk_t> q;
+#endif
+
+} video_capture_t;
+#endif
+
 static struct {
 	struct {
-		FILE * handle;
-		Bit16s buf[WAVE_BUF][2];
-		Bitu used;
-		Bit32u length;
-		Bit32u freq;
-	} wave; 
+		FILE *  handle;
+		Bit16s  buf[WAVE_BUF][2];
+		Bitu    used;
+		Bit32u  length;
+		Bit32u  freq;
+	} wave;
 	struct {
-		FILE * handle;
-		Bit8u buffer[MIDI_BUF];
-		Bitu used,done;
-		Bit32u last;
+		FILE *  handle;
+		Bit8u   buffer[MIDI_BUF];
+		Bitu    used,done;
+		Bit32u  last;
 	} midi;
 	struct {
-		Bitu rowlen;
+		Bitu    rowlen;
 	} image;
 #if (C_SSHOT)
-	struct {
-		FILE		*handle;
-		Bitu		frames;
-		Bit16s		audiobuf[WAVE_BUF][2];
-		Bitu		audioused;
-		Bitu		audiorate;
-		Bitu		audiowritten;
-		VideoCodec	*codec;
-		Bitu		width, height, bpp;
-		Bitu		written;
-		float		fps;
-		int			bufSize;
-		void		*buf;
-		Bit8u		*index;
-		Bitu		indexsize, indexused;
-	} video;
+	video_capture_t video;
 #endif
 } capture;
 
@@ -96,7 +131,7 @@
 		Cross::CreateDir(capturedir);
 		dir=open_directory(capturedir.c_str());
 		if(!dir) {
-		
+
 			LOG_MSG("Can't open dir %s for capturing %s",capturedir.c_str(),type);
 			return 0;
 		}
@@ -109,7 +144,7 @@
 	bool testRead = read_directory_first(dir, tempname, is_directory );
 	for ( ; testRead; testRead = read_directory_next(dir, tempname, is_directory) ) {
 		char * test=strstr(tempname,ext);
-		if (!test || strlen(test)!=strlen(ext)) 
+		if (!test || strlen(test)!=strlen(ext))
 			continue;
 		*test=0;
 		if (strncasecmp(tempname,file_start,strlen(file_start))!=0) continue;
@@ -134,7 +169,7 @@
 	Bit8u chunk[8];Bit8u *index;Bit32u pos, writesize;
 
 	chunk[0] = tag[0];chunk[1] = tag[1];chunk[2] = tag[2];chunk[3] = tag[3];
-	host_writed(&chunk[4], size);   
+	host_writed(&chunk[4], size);
 	/* Write the actual data */
 	fwrite(chunk,1,8,capture.video.handle);
 	writesize = (size+1)&~1;
@@ -157,25 +192,17 @@
 	host_writed(index+8, pos);
 	host_writed(index+12, size);
 }
-#endif
-
-#if (C_SSHOT)
-static void CAPTURE_VideoEvent(bool pressed) {
-	if (!pressed)
-		return;
-	if (CaptureState & CAPTURE_VIDEO) {
-		/* Close the video */
-		CaptureState &= ~CAPTURE_VIDEO;
-		LOG_MSG("Stopped capturing video.");	
 
+static void CAPTURE_VideoHeader() {
 		Bit8u avi_header[AVI_HEADER_SIZE];
 		Bitu main_list;
 		Bitu header_pos=0;
+		Bitu save_pos=ftell(capture.video.handle);
 #define AVIOUT4(_S_) memcpy(&avi_header[header_pos],_S_,4);header_pos+=4;
 #define AVIOUTw(_S_) host_writew(&avi_header[header_pos], _S_);header_pos+=2;
 #define AVIOUTd(_S_) host_writed(&avi_header[header_pos], _S_);header_pos+=4;
 		/* Try and write an avi header */
-		AVIOUT4("RIFF");                    // Riff header 
+		AVIOUT4("RIFF");                    // Riff header
 		AVIOUTd(AVI_HEADER_SIZE + capture.video.written - 8 + capture.video.indexused);
 		AVIOUT4("AVI ");
 		AVIOUT4("LIST");                    // List header
@@ -205,7 +232,7 @@
 		AVIOUTd(4 + 8 + 56 + 8 + 40);       /* Size of the list */
 		AVIOUT4("strl");
 		/* video stream header */
-        AVIOUT4("strh");
+		AVIOUT4("strh");
 		AVIOUTd(56);                        /* # of bytes to follow */
 		AVIOUT4("vids");                    /* Type */
 		AVIOUT4(CODEC_4CC);		            /* Handler */
@@ -287,16 +314,159 @@
 		fwrite( capture.video.index, 1, capture.video.indexused, capture.video.handle);
 		fseek(capture.video.handle, 0, SEEK_SET);
 		fwrite(&avi_header, 1, AVI_HEADER_SIZE, capture.video.handle);
+		fseek(capture.video.handle, save_pos, SEEK_SET);
+}
+
+SDL_cond* non_empty_queue = SDL_CreateCond();
+
+static void CAPTURE_VideoEvent(bool pressed) {
+	if (!pressed)
+		return;
+	if (CaptureState & CAPTURE_VIDEO) {
+
+		/* Close the video */
+		CaptureState &= ~CAPTURE_VIDEO;
+
+#if (C_THREADED_CAPTURE)
+		/* Waits for thread to finish */
+		if (capture.video.thread_running) {
+			LOG_MSG("Finalizing video. Please wait...");
+			SDL_CondSignal(non_empty_queue);
+			SDL_WaitThread(video_thread,NULL);
+		}
+#endif
+		/* Adds AVI header to the file */
+		CAPTURE_VideoHeader();
+
+		/* Close video file and free memory */
 		fclose( capture.video.handle );
 		free( capture.video.index );
 		free( capture.video.buf );
 		delete capture.video.codec;
 		capture.video.handle = 0;
+
+		LOG_MSG("Stopped capturing video.");
+
 	} else {
-		CaptureState |= CAPTURE_VIDEO;
+		if (!capture.video.thread_running)
+			CaptureState |= CAPTURE_VIDEO;
 	}
 }
-#endif
+
+int CAPTURE_VideoCompressFrame(video_capture_t *videohandle, video_chunk_t chunk) {
+	Bit8u doubleRow[SCALER_MAXWIDTH*4];
+	Bitu countWidth = videohandle->width;
+	int codecFlags;
+
+	if (videohandle->frames % 300 == 0)
+		codecFlags = 1;
+	else codecFlags = 0;
+	if (!videohandle->codec->PrepareCompressFrame( codecFlags, videohandle->format, (char *)chunk.pal, videohandle->buf, videohandle->bufSize))
+	{
+		CAPTURE_VideoEvent(true);
+		return 1;
+	}
+
+	for (Bit32u i=0;i<videohandle->height;i++) {
+		void * rowPointer;
+		if (videohandle->flags & CAPTURE_FLAG_DBLW) {
+			void *srcLine;
+			Bitu x;
+			Bitu countWidth = videohandle->width >> 1;
+			if (videohandle->flags & CAPTURE_FLAG_DBLH)
+				srcLine=(chunk.videobuf+(i >> 1)*videohandle->pitch);
+			else
+				srcLine=(chunk.videobuf+(i >> 0)*videohandle->pitch);
+			switch ( videohandle->bpp) {
+			case 8:
+				for (x=0;x<countWidth;x++)
+					((Bit8u *)doubleRow)[x*2+0] =
+					((Bit8u *)doubleRow)[x*2+1] = ((Bit8u *)srcLine)[x];
+				break;
+			case 15:
+			case 16:
+				for (x=0;x<countWidth;x++)
+					((Bit16u *)doubleRow)[x*2+0] =
+					((Bit16u *)doubleRow)[x*2+1] = ((Bit16u *)srcLine)[x];
+				break;
+			case 32:
+				for (x=0;x<countWidth;x++)
+					((Bit32u *)doubleRow)[x*2+0] =
+					((Bit32u *)doubleRow)[x*2+1] = ((Bit32u *)srcLine)[x];
+				break;
+			}
+						rowPointer=doubleRow;
+		} else {
+			if (videohandle->flags & CAPTURE_FLAG_DBLH)
+				rowPointer=(chunk.videobuf+(i >> 1)*videohandle->pitch);
+			else
+				rowPointer=(chunk.videobuf+(i >> 0)*videohandle->pitch);
+		}
+		videohandle->codec->CompressLines( 1, &rowPointer );
+	}
+	int written = videohandle->codec->FinishCompressFrame();
+	if (written < 0) {
+		CAPTURE_VideoEvent(true);
+		return 1;
+	}
+	CAPTURE_AddAviChunk( "00dc", written, videohandle->buf, codecFlags & 1 ? 0x10 : 0x0);
+	videohandle->frames++;
+
+	if ( chunk.audioused ) {
+		CAPTURE_AddAviChunk( "01wb", chunk.audioused * 4, chunk.audiobuf, 0);
+		videohandle->audiowritten = chunk.audioused*4;
+	}
+
+	/* Adds AVI header to the file */
+	CAPTURE_VideoHeader();
+
+	return 0;
+}
+
+#if (C_THREADED_CAPTURE)
+video_capture_t *videohandle = NULL;
+SDL_mutex* queue_mutex = SDL_CreateMutex();
+SDL_cond* empty_queue = SDL_CreateCond();
+
+int CAPTURE_VideoThread(void *videohandleptr) {
+	videohandle=(video_capture_t*)videohandleptr;
+	videohandle->thread_running = true;
+	int rc = 0;
+	/* while we have to record */
+	while(CaptureState & CAPTURE_VIDEO) {
+		/* Process queue while it is not empty */
+		while (!videohandle->q.empty()) {
+			int start = SDL_GetTicks();
+			/* Process a block and write it to disk */
+			if (!rc) {
+				rc = CAPTURE_VideoCompressFrame(videohandle,videohandle->q.front());
+			}else{
+				CaptureState &= ~CAPTURE_VIDEO;
+			}
+			free(videohandle->q.front().videobuf);
+			free(videohandle->q.front().audiobuf);
+			free(videohandle->q.front().pal);
+			videohandle->q.pop();
+		}
+		SDL_CondSignal(empty_queue);
+		/* freezes otherwise if we have to finalize the recording (SDL_WaitThread) */
+		if (CaptureState & CAPTURE_VIDEO) {
+			/* Sleep while the queue is empty */
+			SDL_LockMutex(queue_mutex);
+			SDL_CondWait(non_empty_queue, queue_mutex);
+			SDL_UnlockMutex(queue_mutex);
+		}
+	}
+	videohandle->thread_running = false;
+	videohandle = NULL;
+	return rc;
+}
+
+#endif // C_THREADED_CAPTURE
+
+#endif // C_SSHOT
+
+SDL_mutex* max_queue_mutex = SDL_CreateMutex();
 
 void CAPTURE_AddImage(Bitu width, Bitu height, Bitu bpp, Bitu pitch, Bitu flags, float fps, Bit8u * data, Bit8u * pal) {
 #if (C_SSHOT)
@@ -313,7 +483,7 @@
 		return;
 	if (width > SCALER_MAXWIDTH)
 		return;
-	
+
 	if (CaptureState & CAPTURE_IMAGE) {
 		png_structp png_ptr;
 		png_infop info_ptr;
@@ -323,7 +493,7 @@
 		/* Open the actual file */
 		FILE * fp=OpenCaptureFile("Screenshot",".png");
 		if (!fp) goto skip_shot;
-		/* First try to allocate the png structures */
+		/* First try to alloacte the png structures */
 		png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL,NULL, NULL);
 		if (!png_ptr) goto skip_shot;
 		info_ptr = png_create_info_struct(png_ptr);
@@ -331,18 +501,18 @@
 			png_destroy_write_struct(&png_ptr,(png_infopp)NULL);
 			goto skip_shot;
 		}
-	
+
 		/* Finalize the initing of png library */
 		png_init_io(png_ptr, fp);
 		png_set_compression_level(png_ptr,Z_BEST_COMPRESSION);
-		
+
 		/* set other zlib parameters */
 		png_set_compression_mem_level(png_ptr, 8);
 		png_set_compression_strategy(png_ptr,Z_DEFAULT_STRATEGY);
 		png_set_compression_window_bits(png_ptr, 15);
 		png_set_compression_method(png_ptr, 8);
 		png_set_compression_buffer_size(png_ptr, 8192);
-	
+
 		if (bpp==8) {
 			png_set_IHDR(png_ptr, info_ptr, width, height,
 				8, PNG_COLOR_TYPE_PALETTE, PNG_INTERLACE_NONE,
@@ -359,24 +529,8 @@
 				8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,
 				PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
 		}
-#ifdef PNG_TEXT_SUPPORTED
-		int fields = 1;
-		png_text text[1];
-		const char* text_s = "DOSBox " VERSION;
-		size_t strl = strlen(text_s);
-		char* ptext_s = new char[strl + 1];
-		strcpy(ptext_s, text_s);
-		char software[9] = { 'S','o','f','t','w','a','r','e',0};
-		text[0].compression = PNG_TEXT_COMPRESSION_NONE;
-		text[0].key  = software;
-		text[0].text = ptext_s;
-		png_set_text(png_ptr, info_ptr, text, fields);
-#endif
-		png_write_info(png_ptr, info_ptr);
-#ifdef PNG_TEXT_SUPPORTED
-		delete [] ptext_s;
-#endif
-		for (i=0;i<height;i++) {
+ 			png_write_info(png_ptr, info_ptr);
+ 		for (i=0;i<height;i++) {
 			void *rowPointer;
 			void *srcLine;
 			if (flags & CAPTURE_FLAG_DBLH)
@@ -387,7 +541,7 @@
 			switch (bpp) {
 			case 8:
 				if (flags & CAPTURE_FLAG_DBLW) {
-   					for (Bitu x=0;x<countWidth;x++)
+	 					for (Bitu x=0;x<countWidth;x++)
 						doubleRow[x*2+0] =
 						doubleRow[x*2+1] = ((Bit8u *)srcLine)[x];
 					rowPointer = doubleRow;
@@ -457,120 +611,137 @@
 	}
 skip_shot:
 	if (CaptureState & CAPTURE_VIDEO) {
-		zmbv_format_t format;
-		/* Disable capturing if any of the test fails */
+
+		/* Restarts capturing if any of the test fails */
 		if (capture.video.handle && (
 			capture.video.width != width ||
 			capture.video.height != height ||
 			capture.video.bpp != bpp ||
-			capture.video.fps != fps)) 
-		{
+			capture.video.fps != fps)) {
+
+			/* Ends current capturing */
 			CAPTURE_VideoEvent(true);
+			/* Toggle video capture event */
+			CaptureState |= CAPTURE_VIDEO;
 		}
-		CaptureState &= ~CAPTURE_VIDEO;
+
+		/* Choose video format */
 		switch (bpp) {
-		case 8:format = ZMBV_FORMAT_8BPP;break;
-		case 15:format = ZMBV_FORMAT_15BPP;break;
-		case 16:format = ZMBV_FORMAT_16BPP;break;
-		case 32:format = ZMBV_FORMAT_32BPP;break;
+		case 8:capture.video.format = ZMBV_FORMAT_8BPP;break;
+		case 15:capture.video.format = ZMBV_FORMAT_15BPP;break;
+		case 16:capture.video.format = ZMBV_FORMAT_16BPP;break;
+		case 32:capture.video.format = ZMBV_FORMAT_32BPP;break;
 		default:
-			goto skip_video;
+			CAPTURE_VideoEvent(true);
+			return;
 		}
+
+		/* Initialize video handle */
 		if (!capture.video.handle) {
 			capture.video.handle = OpenCaptureFile("Video",".avi");
-			if (!capture.video.handle)
-				goto skip_video;
+			if (!capture.video.handle) {
+				CAPTURE_VideoEvent(true);
+				return;
+			}
 			capture.video.codec = new VideoCodec();
-			if (!capture.video.codec)
-				goto skip_video;
-			if (!capture.video.codec->SetupCompress( width, height)) 
-				goto skip_video;
-			capture.video.bufSize = capture.video.codec->NeededSize(width, height, format);
+			if (!capture.video.codec) {
+				CAPTURE_VideoEvent(true);
+				return;
+			}
+			if (!capture.video.codec->SetupCompress( width, height)) {
+				CAPTURE_VideoEvent(true);
+				return;
+			}
+			capture.video.bufSize = capture.video.codec->NeededSize(width, height, capture.video.format);
 			capture.video.buf = malloc( capture.video.bufSize );
-			if (!capture.video.buf)
-				goto skip_video;
+			if (!capture.video.buf) {
+				CAPTURE_VideoEvent(true);
+				return;
+			}
 			capture.video.index = (Bit8u*)malloc( 16*4096 );
-			if (!capture.video.buf)
-				goto skip_video;
+			if (!capture.video.index) {
+				CAPTURE_VideoEvent(true);
+				return;
+			}
 			capture.video.indexsize = 16*4096;
 			capture.video.indexused = 8;
 
 			capture.video.width = width;
 			capture.video.height = height;
+			capture.video.pitch = pitch;
+			capture.video.flags = flags;
 			capture.video.bpp = bpp;
 			capture.video.fps = fps;
-			for (i=0;i<AVI_HEADER_SIZE;i++)
+			for (int i=0;i<AVI_HEADER_SIZE;i++)
 				fputc(0,capture.video.handle);
 			capture.video.frames = 0;
 			capture.video.written = 0;
 			capture.video.audioused = 0;
 			capture.video.audiowritten = 0;
+			capture.video.thread_running = false;
+
 		}
-		int codecFlags;
-		if (capture.video.frames % 300 == 0)
-			codecFlags = 1;
-		else codecFlags = 0;
-		if (!capture.video.codec->PrepareCompressFrame( codecFlags, format, (char *)pal, capture.video.buf, capture.video.bufSize))
-			goto skip_video;
-
-		for (i=0;i<height;i++) {
-			void * rowPointer;
-			if (flags & CAPTURE_FLAG_DBLW) {
-				void *srcLine;
-				Bitu x;
-				Bitu countWidth = width >> 1;
-				if (flags & CAPTURE_FLAG_DBLH)
-					srcLine=(data+(i >> 1)*pitch);
-				else
-					srcLine=(data+(i >> 0)*pitch);
-				switch ( bpp) {
-				case 8:
-					for (x=0;x<countWidth;x++)
-						((Bit8u *)doubleRow)[x*2+0] =
-						((Bit8u *)doubleRow)[x*2+1] = ((Bit8u *)srcLine)[x];
-					break;
-				case 15:
-				case 16:
-					for (x=0;x<countWidth;x++)
-						((Bit16u *)doubleRow)[x*2+0] =
-						((Bit16u *)doubleRow)[x*2+1] = ((Bit16u *)srcLine)[x];
-					break;
-				case 32:
-					for (x=0;x<countWidth;x++)
-						((Bit32u *)doubleRow)[x*2+0] =
-						((Bit32u *)doubleRow)[x*2+1] = ((Bit32u *)srcLine)[x];
-					break;
-				}
-                rowPointer=doubleRow;
-			} else {
-				if (flags & CAPTURE_FLAG_DBLH)
-					rowPointer=(data+(i >> 1)*pitch);
-				else
-					rowPointer=(data+(i >> 0)*pitch);
-			}
-			capture.video.codec->CompressLines( 1, &rowPointer );
-		}
-		int written = capture.video.codec->FinishCompressFrame();
-		if (written < 0)
-			goto skip_video;
-		CAPTURE_AddAviChunk( "00dc", written, capture.video.buf, codecFlags & 1 ? 0x10 : 0x0);
-		capture.video.frames++;
-//		LOG_MSG("Frame %d video %d audio %d",capture.video.frames, written, capture.video.audioused *4 );
-		if ( capture.video.audioused ) {
-			CAPTURE_AddAviChunk( "01wb", capture.video.audioused * 4, capture.video.audiobuf, 0);
-			capture.video.audiowritten = capture.video.audioused*4;
-			capture.video.audioused = 0;
+
+		video_chunk_t chunk;
+
+#if (C_THREADED_CAPTURE)
+		/* Create video chunk buffers */
+		chunk.videobuf = (Bit8u *)malloc(capture.video.height*capture.video.pitch);
+		if (!chunk.videobuf) {
+			CAPTURE_VideoEvent(true);
+			return;
 		}
+		chunk.audiobuf = (Bit16s *)malloc(capture.video.audioused*4);
+		if (!chunk.audiobuf) {
+			CAPTURE_VideoEvent(true);
+			return;
+		}
+		chunk.pal = (Bit8u *)malloc(256*4);
+		if (!chunk.pal) {
+			CAPTURE_VideoEvent(true);
+			return;
+		}
+		/* Copy data to chunk */
+		memcpy(chunk.videobuf,data,capture.video.height*capture.video.pitch);
+		memcpy(chunk.audiobuf,&capture.video.audiobuf, capture.video.audioused*4);
+		memcpy(chunk.pal,pal,256*4);
+		chunk.audioused = capture.video.audioused;
+		capture.video.audioused = 0;
+
+		/* Push avi chunk to queue */
+		capture.video.q.push(chunk);
+		
+		/*Wake up thread*/
+		SDL_CondSignal(non_empty_queue);
+		
+		/* If queue exceeds size limit, wait for capture thread to empty queue */
+		if (capture.video.q.size()>MAX_QUEUE_SIZE) {
+			LOG_MSG("Writing video to disk. Please wait...");
+			SDL_LockMutex(max_queue_mutex);
+			SDL_CondWait(empty_queue, max_queue_mutex);
+			SDL_UnlockMutex(max_queue_mutex);
+		}
+
+		/* If thread is not already running, start it */
+		if (!videohandle)
+			video_thread = SDL_CreateThread(CAPTURE_VideoThread, (void*)&capture.video);
+
+#else
+		/* Compress frame directly (no thread) */
+		chunk.videobuf	= data;
+		chunk.audiobuf	= (Bit16s*)&capture.video.audiobuf;
+		chunk.audioused	= capture.video.audioused;
+		chunk.pal		= pal;
+		capture.video.audioused = 0;
+		CAPTURE_VideoCompressFrame(&capture.video,chunk);
+#endif
 
-		/* Everything went okay, set flag again for next frame */
-		CaptureState |= CAPTURE_VIDEO;
 	}
-skip_video:
+
 #endif
 	return;
 }
 
-
 #if (C_SSHOT)
 static void CAPTURE_ScreenShotEvent(bool pressed) {
 	if (!pressed)
@@ -645,13 +816,13 @@
 		host_writed(&wavheader[0x18],capture.wave.freq);
 		host_writed(&wavheader[0x1C],capture.wave.freq*4);
 		host_writed(&wavheader[0x28],capture.wave.length);
-		
+
 		fseek(capture.wave.handle,0,0);
 		fwrite(wavheader,1,sizeof(wavheader),capture.wave.handle);
 		fclose(capture.wave.handle);
 		capture.wave.handle=0;
 		CaptureState |= CAPTURE_WAVE;
-	} 
+	}
 	CaptureState ^= CAPTURE_WAVE;
 }
 
@@ -701,7 +872,7 @@
 		RawMidiAdd( 0xf0 );
 		RawMidiAddNumber( len );
 	}
-	for (Bitu i=0;i<len;i++) 
+	for (Bitu i=0;i<len;i++)
 		RawMidiAdd(data[i]);
 }
 
@@ -731,7 +902,7 @@
 		capture.midi.handle=0;
 		CaptureState &= ~CAPTURE_MIDI;
 		return;
-	} 
+	}
 	CaptureState ^= CAPTURE_MIDI;
 	if (CaptureState & CAPTURE_MIDI) {
 		LOG_MSG("Preparing for raw midi capture, will start with first data.");
@@ -758,9 +929,6 @@
 #endif
 	}
 	~HARDWARE(){
-#if (C_SSHOT)
-		if (capture.video.handle) CAPTURE_VideoEvent(true);
-#endif
 		if (capture.wave.handle) CAPTURE_WaveEvent(true);
 		if (capture.midi.handle) CAPTURE_MidiEvent(true);
 	}
